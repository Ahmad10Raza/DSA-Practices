# Searching Algorithms:

1. **Linear Search**: A simple algorithm that searches for a target value in a list sequentially.
2. **Binary Search**: An efficient algorithm that searches for a target value in a sorted list by dividing the search interval in half.
3. **Interpolation Search**: Similar to binary search, but uses a different method to calculate the search interval.
4. **Exponential Search**: An improvement over binary search that starts with a small interval and exponentially increases it.
5. **Jump Search**: Divides the array into blocks and jumps through the blocks to find the range where the target may be.
6. **Fibonacci Search**: A variant of binary search that uses Fibonacci numbers for search intervals.

# Sorting Algorithms:

1. **Bubble Sort**: A simple sorting algorithm that repeatedly swaps adjacent elements if they are in the wrong order.
2. **Selection Sort**: A sorting algorithm that repeatedly selects the minimum element from an unsorted list and swaps it with the first element.
3. **Insertion Sort**: A sorting algorithm that builds a sorted portion of the list one element at a time.
4. **Merge Sort**: A divide-and-conquer algorithm that splits the list in half, sorts each half, and merges them back together.
5. **Quick Sort**: A fast, divide-and-conquer algorithm that uses a pivot to partition the list and recursively sort the sublists.
6. **Heap Sort**: A sorting algorithm that uses a binary heap data structure to sort the list.
7. **Shell Sort**: An improvement over insertion sort that uses a gap sequence to reduce the number of swaps.
8. **Radix Sort**: A non-comparison-based sorting algorithm that sorts based on the individual digits of the values.
9. **Counting Sort**: A non-comparison-based sorting algorithm that works by counting the occurrences of each value.
10. **Bucket Sort**: A non-comparison-based sorting algorithm that divides the list into buckets and sorts each bucket individually.

These algorithms provide a good foundation for understanding the various ways to search and sort data. Once you understand these algorithms, you can explore more advanced and specialized techniques as well. Let me know if you need a more detailed explanation of any of these algorithms!
